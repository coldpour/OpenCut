import type {
	MarbleAuthorList,
	MarbleCategoryList,
	MarblePost,
	MarblePostList,
	MarbleTagList,
} from "@/types/blog";
import { unified } from "unified";
import rehypeParse from "rehype-parse";
import rehypeStringify from "rehype-stringify";
import rehypeSlug from "rehype-slug";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypeSanitize from "rehype-sanitize";

const url =
	process.env.NEXT_PUBLIC_MARBLE_API_URL ?? "https://api.marblecms.com";
const key = process.env.MARBLE_WORKSPACE_KEY ?? "cmd4iw9mm0006l804kwqv0k46";

const EMPTY_PAGINATION = {
	limit: 0,
	currpage: 1,
	nextPage: null,
	prevPage: null,
	totalItems: 0,
	totalPages: 0,
} as const;

async function fetchFromMarble<T>({
	endpoint,
}: {
	endpoint: string;
}): Promise<T> {
	try {
		const response = await fetch(`${url}/${key}/${endpoint}`);
		if (!response.ok) {
			throw new Error(
				`Failed to fetch ${endpoint}: ${response.status} ${response.statusText}`,
			);
		}
		return (await response.json()) as T;
	} catch (error) {
		console.error(`Error fetching ${endpoint}:`, error);
		throw error;
	}
}

export async function getPosts() {
	try {
		return await fetchFromMarble<MarblePostList>({ endpoint: "posts" });
	} catch {
		return {
			posts: [],
			pagination: EMPTY_PAGINATION,
		};
	}
}

export async function getTags() {
	try {
		return await fetchFromMarble<MarbleTagList>({ endpoint: "tags" });
	} catch {
		return {
			tags: [],
			pagination: EMPTY_PAGINATION,
		};
	}
}

export async function getSinglePost({ slug }: { slug: string }) {
	return fetchFromMarble<MarblePost>({ endpoint: `posts/${slug}` });
}

export async function getCategories() {
	try {
		return await fetchFromMarble<MarbleCategoryList>({ endpoint: "categories" });
	} catch {
		return {
			categories: [],
			pagination: EMPTY_PAGINATION,
		};
	}
}

export async function getAuthors() {
	try {
		return await fetchFromMarble<MarbleAuthorList>({ endpoint: "authors" });
	} catch {
		return {
			authors: [],
			pagination: EMPTY_PAGINATION,
		};
	}
}

export async function processHtmlContent({
	html,
}: {
	html: string;
}): Promise<string> {
	const processor = unified()
		.use(rehypeSanitize)
		.use(rehypeParse, { fragment: true })
		.use(rehypeSlug)
		.use(rehypeAutolinkHeadings, { behavior: "append" })
		.use(rehypeStringify);

	const file = await processor.process({ value: html, type: "html" });
	return String(file);
}
